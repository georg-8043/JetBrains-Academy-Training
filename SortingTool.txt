Description
Sometimes it's useful to read data from a file and write the result to another file.

Implement parsing of two more arguments: -inputFile and -outputFile.
If the -inputFile argument is provided, read input data from the file with the given name.
If the -outputFile argument is provided, only print info messages to the console (like errors parsing arguments).
Print the results to the file.

Run examples
Example 1:

java SortingTool -sortingType byCount -inputFile input.txt
Example 2:

java SortingTool -sortingType byCount -inputFile data.dat -outputFile out.txt

--------------------- STAGE 5 ---------------------------

Description
What if someone runs your program like this: java SortingTool -sortingType? The value of the -sortingType argument is missing!

And what if -dataType argument is long but there are words in the input text?

What if there are unknown arguments?

Let's handle these errors.

In summary, for this stage, implement error messages when the input is wrong.

Examples
Notice that '>' symbol represents the start of the input (not including symbol itself):

Example 1:

$> java SortingTool -sortingType natural -dataType long
> 1 -2   33 4
> 42
> 1                 1
Total numbers: 7
Sorted data: -2 1 1 1 4 42 333
Example 2:

$> java SortingTool -sortingType byCount -dataType long
> 1 -2   33 4
> 42
> 1                 1
Total numbers: 7.
-2: 1 time(s), 14%
4: 1 time(s), 14%
33: 1 time(s), 14%
42: 1 time(s), 14%
1: 3 time(s), 43%
Example 3:

$> java SortingTool -sortingType
No sorting type defined!
Example 4:

$> java SortingTool -dataType
No data type defined!
Example 5:

$> java SortingTool -dataType long -sortingType natural -abc -def
"-abc" isn't a valid parameter. It's skipped.
"-def" isn't a valid parameter. It's skipped.
> a 2 -42
"a" isn't a long. It's skipped.
Total numbers: 2.
Sorted data: -42 2
 Write a program
 
---------------- STAGE 4 -------------------

Description
In this stage, you should implement sorting by count. The result should be pairs like (count, dataEntry) sorted by count.

Remove parsing of the -sortIntegers argument. Instead of this argument add another - named -sortingType.  This argument can be followed by natural or byCount sorting types. If -sortingType is not presented among argument list then consider natural to be the default sorting type.

If -dataType is word or line, use String.compareTo(String) method to compare strings in sorting.

To sum up, your program should support two sorting methods now and work with all types of data.

How-to
You can use the following algorithm:

Sort data entries into List<DataType> sortedDataEntries.
Iterate over it and create Map<DataType, Integer> dataEntryToCount.
Iterate over it and create List<Integer> counts.
Sort it into List<Integer> sortedCounts and remove duplicates in it.
Iterate over dataEntryToCount and create Map<Integer, Set<DataEntry>> countToDataEntries.
Now iterate over sortedCounts and print all data entries from countToDataEntries.get(count).
Or you can use sorting with comparator to skip the last four actions.

Examples
Run configuration examples:

java SortingTool -sortingType natural -dataType long
java SortingTool -dataType word -sortingType byCount
Run examples:

Input:

1 -2   33 4
42
1                 1
Output for sorting longs by count:

Total numbers: 7.
-2: 1 time(s), 14%
4: 1 time(s), 14%
33: 1 time(s), 14%
42: 1 time(s), 14%
1: 3 time(s), 43%
Output for sorting numbers naturally:

Total numbers: 7
Sorted data: -2 1 1 1 4 42 33
Output for sorting words naturally:

Total words: 7
Sorted data: -2 1 1 1 33 4 42
Output for sorting lines naturally:

Total lines: 3
Sorted data:
1                 1
1 -2   33 4
42