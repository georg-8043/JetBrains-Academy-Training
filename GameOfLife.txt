
Stage 5/5
Description
As we did in the previous stage, we are going to make application interactive. Just add two buttons: one should toggle pause/resume, another should start evolution over again, with a different initial state.



After this, you will have an application that provides a comfortable experience of the Game of Life. Optionally you can add more features:

increasing/decreasing evolution speed (use buttons or JSlider)

color of cells (use JColorChooser or JComboBox)

setting size of the new field (use JTextField or JDialog)

save/load (use JFileChooser)

and so on.

For the testing reasons, you need to set the name of each component using the method component.setName(String name).

Name your labels with names "GenerationLabel" and "AliveLabel".
Name your buttons with names "PlayToggleButton" and "ResetButton".
---------------------------

Stage 4/5
Description
Now you are ready to put aside the console and make your application look like this:



Just create a window that displays the field of the game and counters (current generation and number of alive cells). For displaying the field, you can use methods that draw lines and fill rectangles. For counters, use simple text labels.

It may look like you need to make a different application, but if you’re using the MVC pattern, you can add one or two classes to your code.

The application should start and begin to update its look with every new generation in the game. For this stage no interaction with the user is necessary.

Testing
You should create a class named GameOfLife. This will be a class that represents a GUI. Here's its initial template. Note that the constructor should not have any parameters.

package life;

import javax.swing.*;

public class GameOfLife extends JFrame {
    public GameOfLife() {
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(300, 300);
        setVisible(true);
    }
}
For the testing reasons, you need to set the name of each component using the method component.setName(String name).

Name your labels with names "GenerationLabel" and "AliveLabel".
---------------------------

Stage 3/5
Description
Well, now the universe is created, and its laws work properly.

Let’s visualize evolution. In the previous stage, we could see only one generation. It would be better if each generation was displayed. But our perception is not as fast as computer’s, so our application should sleep a little after each generation.

Use methods of the class java.lang.Thread to achieve this goal.

You can do this in two ways:

output every generation to the console, one after one

clear the console output before the next generation appears

Due to the cross-platform nature of Java, the second way can be complicated. You can use this code to clear the console output.

try {
    if (System.getProperty("os.name").contains("Windows"))
        new ProcessBuilder("cmd","/c","cls").inheritIO().start().waitFor();
    else
        Runtime.getRuntime().exec("clear");
}
catch (IOException | InterruptedException e) {}
The only input is a number for the size of the universe. The universe for this stage is a square. Also, in this stage you shouldn't set the seed to generate an initial position, it should be random.

The launched application must show evolution in progress. You should output at least 10 generations before stoppint the application.
-------------------------------------

Stage 2/5
Description
The progress of the game is evolution: one generation changes another. Each generation is fully determined by the previous generation. The future of each cell depends on its neighbours (adjacent cells).



As you can notice, each cell has eight neighbors. We consider the universe to be periodic: border cells also have eight neighbors. For example:

If cell is right-border, its right (east) neighbor is leftmost cell in the same row.
If cell is bottom-border, its bottom (south) neighbor is topmost cell in the same column.

Corner cells use both solutions.



Evolution is controlled by two rules:

An alive cell survives if has two or three alive neighbors; otherwise, it dies of boredom (<2) or overpopulation (>3)

A dead cell is reborn if it has exactly three alive neighbors

The program should apply these rules to each cell in order to compute the next generation.

At this stage, you should make several consecutive generations. For this, you have to store the state of the universe in memory.

Use 2-dimensional arrays for this task. You need two arrays: one for the current generation and one for the next. Add these arrays to the program and implement the algorithm of getting the next generation.

NOTE: it will be better to encapsulate the state of the universe and the generation algorithm in separate classes. You will understand why soon.

The input data is three numbers in one line. The first is N (N>0), the size of the universe; the second is S, a long, that you should use as seed for your Random object; the third is M (M≥0), the number of generations your program should create.

Output data: a square matrix NxN: there must be N lines with N characters in each line. If there is an alive cell, place the letter ‘O’, otherwise, whitespace. The matrix should describe the generation after M steps from the beginning. So if M==8, you should find generation #9 (first is #1).

Examples
The lines that start with > represent user input.

Example 1:

> 4 4 0
OOOO
O O
   O
OOO
Example 2:

> 8 1 10
 O  OO
OO   OO
O     O

  O
  O O
     OO
O   OO O
Example 3:

> 10 10 100


    O
   O O
    O